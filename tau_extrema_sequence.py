def find_naught(p,q,r):
    '''
    Args: 
        p, q, r (int): parameters of the Brieskorn sphere

    Returns: (int): N0, the last index in the tau sequence relevant to the structure of the lattice homology
    '''
    return p*q*r - p*q - q*r - r*p

def needed_semigroup(p,q,r):
    '''
    Args: 
        p, q, r (int): parameters of the Brieskorn sphere

    Returns (list[int]): sorted list of integers in semigroup minimally generated by p*q, q*r, and r*p up to N_0 = p*q*r - p*q - q*r - r*p
    '''
    N0 = find_naught(p,q,r)
    semigroup = []
    for i in range(p-1):
        for j in range(q-1):
            for k in range(r-1):
                if (i*q*r + j*p*r + k*p*q < N0): # maybe could be wasting some time here
                    # adding in nonnegative integer linear combinations of generators
                    semigroup.append(i*q*r + j*p*r + k*p*q)
    semigroup.sort()

    return semigroup

def compute_delta(p,q,r): # should probably test if the direct formula given is faster than numerical semigroup
    '''
    Args:
        p, q, r (int): parameters of the Brieskorn sphere

    Returns (list[int]): the delta sequence associated with this Brieskorn sphere
    '''
    semigroup = needed_semigroup(p,q,r)
    N0 = find_naught(p,q,r)

    # the delta sequence has value 1 at elements in the semigroup, -1 at elements that are N0 minus an element in the semigroup, and 0 otherwise
    delta = [0]*(N0+1)
    for num in semigroup:
        delta[num] = 1
        delta[N0 - num] = -1

    return delta

def compute_tau(p,q,r):
    '''
    Args: 
        p, q, r (int): parameters of the Brieskorn sphere

    Returns (list[int]): the tau sequence associated with this Brieskorn sphere
    '''
    tau = []
    tau.append(0)
    N0 = find_naught(p,q,r)
    deltas = compute_delta(p,q,r)

    # the tau sequences is given as the partial summations of the delta sequence:
    for i in range(1, N0+2):
        tau.append(tau[-1] + deltas[i-1])
    
    return tau

def compress_tau(p,q,r):
    '''
    Args:
        p, q, r (int): parmaeters of the Brieskorn sphere

    Returns (list[int]): returns the compressed tau sequence, which is the tau sequence with consecutive duplicates removed
    '''
    tau = compute_tau(p,q,r)
    compress = []
    compress.append(0)
    N0 = find_naught(p,q,r)

    for i in range(N0+2):
        # check if the number we just added to the compressed tau sequence equals the next number in the tau sequence; if not, add the next number
        if compress[-1] != tau[i]:
            compress.append(tau[i])
    return compress

def extrema_sequence(p,q,r):
    '''
    Args:
        p, q, r (int): parameters of the Brieskorn sphere

    Returns (list[int]): returns the extrema sequence, the list of local extrema in the compressed tau sequence
    '''
    N0 = find_naught(p,q,r)
    compress = compress_tau(p,q,r)
    ret = []

    if compress[1] > compress[0]:
        ret.append(0)

    # may be a bit more concise way to rewrite this code using multiplication of differences
    for i in range(1, len(compress)-1):
        if compress[i] > compress[i-1] and compress[i] > compress[i+1]:
            ret.append(compress[i])
        if compress[i] < compress[i-1] and compress[i] < compress[i+1]:
            ret.append(compress[i])
    if compress[-1] < compress[-2]:
        ret.append(compress[-1])
    return ret

def main():
    p = int(input("p: "))
    q = int(input("q: "))
    r = int(input("r: "))
    print(len(extrema_sequence(p,q,r)))
    print(extrema_sequence(p,q,r))
    print(compute_delta(p,q,r))
    print(compute_tau(p,q,r))

if __name__ == "__main__":
    main()